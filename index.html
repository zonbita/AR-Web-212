<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>AR.js GLB Model on Marker</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/three.js/build/ar-threex.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      
      #loading {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 100;
      }
      
      #instructions {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        background: rgba(0,0,0,0.7);
        padding: 15px;
        border-radius: 5px;
        text-align: center;
        max-width: 300px;
      }
    </style>
  </head>
  <body>
    <div id="loading">Loading AR...</div>
    <div id="instructions">Point camera at marker to see 3D model</div>

    <script>
      // --- Scene, Camera, Renderer ---
      const scene = new THREE.Scene();
      const camera = new THREE.Camera();
      scene.add(camera);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // Add ambient light for better visibility
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      // Add directional light with shadows
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 2, 1);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // --- Source webcam ---
      const arSource = new THREEx.ArToolkitSource({
        sourceType: "webcam",
      });

      arSource.init(function () {
        setTimeout(function () {
          arSource.onResizeElement();
          arSource.copyElementSizeTo(renderer.domElement);
          document.getElementById("loading").textContent = "AR Ready - Point at marker";
        }, 2000);
      });

      window.addEventListener("resize", function () {
        arSource.onResizeElement();
        arSource.copyElementSizeTo(renderer.domElement);
      });

      // --- Context AR ---
      const arContext = new THREEx.ArToolkitContext({
        cameraParametersUrl: "camera_para.dat",
        detectionMode: "mono",
      });

      arContext.init(function () {
        camera.projectionMatrix.copy(arContext.getProjectionMatrix());
      });

      // --- Marker root with smoothing ---
      const markerRoot = new THREE.Group();
      scene.add(markerRoot);

      const markerControls = new THREEx.ArMarkerControls(
        arContext,
        markerRoot,
        {
          type: "pattern",
          patternUrl: "pattern-spider-man-logo.patt",
          smooth: true,
          smoothCount: 10,
          smoothTolerance: 0.01,
          smoothThreshold: 0.01,
        }
      );

      // --- GLB Model Loading ---
      const loader = new THREE.GLTFLoader();
      let model = null;
      let modelMixer = null;

      // Replace 'your-model.glb' with your actual GLB file path
      const modelPath = "your-model.glb"; // Change this to your GLB file path

      loader.load(
        modelPath,
        function (gltf) {
          model = gltf.scene;
          
          // Scale the model (adjust as needed)
          model.scale.set(0.5, 0.5, 0.5);
          
          // Position the model (adjust as needed)
          model.position.set(0, 0, 0);
          
          // Rotate the model if needed
          model.rotation.x = 0;
          model.rotation.y = 0;
          model.rotation.z = 0;
          
          // Enable shadows
          model.traverse(function (child) {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              // Ensure materials are visible
              if (child.material) {
                child.material.needsUpdate = true;
              }
            }
          });

          // Add animations if they exist
          if (gltf.animations && gltf.animations.length > 0) {
            modelMixer = new THREE.AnimationMixer(model);
            const action = modelMixer.clipAction(gltf.animations[0]);
            action.play();
          }

          markerRoot.add(model);
          document.getElementById("loading").textContent = "Model loaded successfully!";
          
          setTimeout(() => {
            document.getElementById("loading").style.display = "none";
          }, 2000);
        },
        function (progress) {
          const percent = Math.round((progress.loaded / progress.total) * 100);
          document.getElementById("loading").textContent = `Loading model: ${percent}%`;
        },
        function (error) {
          console.error('Error loading GLB model:', error);
          document.getElementById("loading").textContent = "Error loading model";
          document.getElementById("loading").style.color = "#ff6b6b";
          
          // Create a fallback cube if model fails to load
          const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
          const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
          const cube = new THREE.Mesh(geometry, material);
          cube.position.y = 0.15;
          cube.castShadow = true;
          cube.receiveShadow = true;
          markerRoot.add(cube);
        }
      );

      // --- Animation loop ---
      const clock = new THREE.Clock();
      
      function animate() {
        requestAnimationFrame(animate);
        
        const delta = clock.getDelta();
        
        // Update animation mixer if it exists
        if (modelMixer) {
          modelMixer.update(delta);
        }
        
        // Update AR
        if (arSource.ready) {
          arContext.update(arSource.domElement);
        }
        
        renderer.render(scene, camera);
      }

      animate();

      // --- Optional: Add controls for model manipulation ---
      let isModelVisible = false;
      
      // Track marker visibility
      markerControls.addEventListener('markerFound', function() {
        isModelVisible = true;
        console.log('Marker found - Model should be visible');
      });
      
      markerControls.addEventListener('markerLost', function() {
        isModelVisible = false;
        console.log('Marker lost - Model hidden');
      });

      // Optional: Add click handler to scale model
      document.addEventListener('click', function(event) {
        if (isModelVisible && model) {
          // Cycle through different scales on click
          const currentScale = model.scale.x;
          if (currentScale < 0.8) {
            model.scale.set(0.8, 0.8, 0.8);
          } else {
            model.scale.set(0.3, 0.3, 0.3);
          }
        }
      });
    </script>
  </body>
</html>
